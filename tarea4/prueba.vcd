$date
	Thu Jun 18 02:20:41 2015
$end
$version
	Icarus Verilog
$end
$timescale
	1s
$end
$scope module tester $end
$var wire 10 ! branchDir [9:0] $end
$var wire 1 " branchTaken $end
$var wire 8 # data [7:0] $end
$var wire 16 $ instr [15:0] $end
$var wire 10 % newPC [9:0] $end
$var wire 6 & operation [5:0] $end
$var wire 2 ' outSelMux [1:0] $end
$var wire 8 ( salidaAcumA [7:0] $end
$var wire 8 ) salidaAcumB [7:0] $end
$scope module test $end
$var wire 10 * branchDir [9:0] $end
$var wire 1 " branchTaken $end
$var wire 6 + operation [5:0] $end
$var wire 2 , outSelMux [1:0] $end
$var wire 8 - salidaAcumA [7:0] $end
$var wire 8 . salidaAcumB [7:0] $end
$var reg 10 / clear [9:0] $end
$var reg 8 0 data [7:0] $end
$var reg 16 1 instr [15:0] $end
$var reg 10 2 newPC [9:0] $end
$var reg 10 3 valor [9:0] $end
$upscope $end
$scope module pegado $end
$var wire 10 4 branchDir [9:0] $end
$var wire 1 " branchTaken $end
$var wire 8 5 constant [7:0] $end
$var wire 3 6 controlAcum [2:0] $end
$var wire 8 7 data [7:0] $end
$var wire 16 8 instr [15:0] $end
$var wire 10 9 newPC [9:0] $end
$var wire 6 : operation [5:0] $end
$var wire 2 ; outSelMux [1:0] $end
$var wire 8 < salidaAcumA [7:0] $end
$var wire 8 = salidaAcumB [7:0] $end
$scope module acumuladores $end
$var wire 8 > constant [7:0] $end
$var wire 3 ? control [2:0] $end
$var wire 8 @ data [7:0] $end
$var reg 8 A salidaAcumA [7:0] $end
$var reg 8 B salidaAcumB [7:0] $end
$upscope $end
$scope module decodificador $end
$var wire 8 C constant [7:0] $end
$var wire 16 D instr [15:0] $end
$var wire 6 E instrDecod [5:0] $end
$var wire 10 F instrInfo [9:0] $end
$var wire 10 G newPC [9:0] $end
$var wire 6 H operation [5:0] $end
$var wire 6 I saltoRel [5:0] $end
$var reg 10 J branchDir [9:0] $end
$var reg 1 K branchTaken $end
$var reg 3 L controlAcum [2:0] $end
$var reg 2 M outSelMux [1:0] $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
b0 M
b1 L
0K
b1011 J
b100011 I
b10 H
b1111101000 G
b100011 F
b10 E
b100000100011 D
b100011 C
bx B
b100011 A
b1010 @
b1 ?
b100011 >
bx =
b100011 <
b0 ;
b10 :
b1111101000 9
b100000100011 8
b1010 7
b1 6
b100011 5
b1011 4
b100011 3
b1111101000 2
b100000100011 1
b1010 0
b0 /
bx .
b100011 -
b0 ,
b10 +
b1011 *
bx )
b100011 (
b0 '
b10 &
b1111101000 %
b100000100011 $
b1010 #
0"
b1011 !
$end
#20
b1111101000 J
b1111101000 !
b1111101000 *
b1111101000 4
b0 B
b0 )
b0 .
b0 =
b0 5
b0 >
b0 C
b0 I
b11 L
b11 6
b11 ?
b11 E
b11 &
b11 +
b11 :
b11 H
b0 F
b110000000000 1
b110000000000 $
b110000000000 8
b110000000000 D
#40
b110 J
b110 !
b110 *
b110 4
b11110 5
b11110 >
b11110 C
b11110 I
b0 L
b0 6
b0 ?
1K
1"
b11011 E
b11011 &
b11011 +
b11011 :
b11011 H
b11110 F
b110110000011110 1
b110110000011110 $
b110110000011110 8
b110110000011110 D
b11110 3
#60
b1100 5
b1100 >
b1100 C
b1100 I
b1000001100 J
b1000001100 !
b1000001100 *
b1000001100 4
b11000 E
b11000 &
b11000 +
b11000 :
b11000 H
b1000001100 F
b110001000001100 1
b110001000001100 $
b110001000001100 8
b110001000001100 D
b1000001100 3
#80
