$date
	Wed Jul  1 19:43:07 2015
$end
$version
	Icarus Verilog
$end
$timescale
	1ps
$end
$scope module iFetch $end
$var wire 1 ! clk $end
$var wire 1 " enable $end
$var wire 10 # iBr_dir [9:0] $end
$var wire 1 $ iBr_taken $end
$var wire 16 % oFetchedInst [15:0] $end
$var wire 10 & oNew_pc [9:0] $end
$var wire 1 ' reset $end
$var wire 10 ( wPc_pointer [9:0] $end
$scope module pcIF $end
$var wire 1 ! clk $end
$var wire 1 " enable $end
$var wire 10 ) iBr_dir [9:0] $end
$var wire 1 $ iBr_taken $end
$var wire 1 ' reset $end
$var reg 10 * oNew_pc [9:0] $end
$var reg 10 + oPc_pointer [9:0] $end
$upscope $end
$scope module instructMem $end
$var wire 10 , iDir [9:0] $end
$var reg 16 - oInstruc [15:0] $end
$var reg 10 . rClear [9:0] $end
$upscope $end
$upscope $end
$scope module tester $end
$var wire 10 / branchDir [9:0] $end
$var wire 8 0 constant [7:0] $end
$var wire 3 1 controlAcum_ID [2:0] $end
$var wire 3 2 controlAcum_WB [2:0] $end
$var wire 8 3 data [7:0] $end
$var wire 16 4 instr [15:0] $end
$var wire 2 5 memControl [1:0] $end
$var wire 10 6 newPC [9:0] $end
$var wire 6 7 operation [5:0] $end
$var wire 2 8 outSelMux [1:0] $end
$var wire 8 9 salidaAcumA [7:0] $end
$var wire 8 : salidaAcumB [7:0] $end
$scope module test $end
$var wire 10 ; branchDir [9:0] $end
$var wire 8 < constant [7:0] $end
$var wire 3 = controlAcum_ID [2:0] $end
$var wire 2 > memControl [1:0] $end
$var wire 6 ? operation [5:0] $end
$var wire 2 @ outSelMux [1:0] $end
$var wire 8 A salidaAcumA [7:0] $end
$var wire 8 B salidaAcumB [7:0] $end
$var reg 3 C controlAcum_WB [2:0] $end
$var reg 8 D data [7:0] $end
$var reg 16 E instr [15:0] $end
$var reg 10 F newPC [9:0] $end
$upscope $end
$scope module pegado $end
$var wire 10 G branchDir [9:0] $end
$var wire 8 H constant [7:0] $end
$var wire 3 I controlAcum_ID [2:0] $end
$var wire 3 J controlAcum_WB [2:0] $end
$var wire 8 K data [7:0] $end
$var wire 16 L instr [15:0] $end
$var wire 2 M memControl [1:0] $end
$var wire 10 N newPC [9:0] $end
$var wire 6 O operation [5:0] $end
$var wire 2 P outSelMux [1:0] $end
$var wire 8 Q salidaAcumA [7:0] $end
$var wire 8 R salidaAcumB [7:0] $end
$scope module acumuladores $end
$var wire 3 S control [2:0] $end
$var wire 8 T data [7:0] $end
$var reg 8 U salidaAcumA [7:0] $end
$var reg 8 V salidaAcumB [7:0] $end
$upscope $end
$scope module decodificador $end
$var wire 8 W constant [7:0] $end
$var wire 16 X instr [15:0] $end
$var wire 6 Y instrDecod [5:0] $end
$var wire 10 Z instrInfo [9:0] $end
$var wire 10 [ newPC [9:0] $end
$var wire 6 \ operation [5:0] $end
$var wire 6 ] saltoRel [5:0] $end
$var reg 10 ^ branchDir [9:0] $end
$var reg 3 _ controlAcum [2:0] $end
$var reg 2 ` memControl [1:0] $end
$var reg 2 a outSelMux [1:0] $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
b0 a
b0 `
b1 _
b1000 ^
b111 ]
b10 \
b1 [
b111 Z
b10 Y
b100000000111 X
b111 W
bx V
b111 U
b111 T
b1 S
bx R
b111 Q
b0 P
b10 O
b1 N
b0 M
b100000000111 L
b111 K
b1 J
b1 I
b111 H
b1000 G
b1 F
b100000000111 E
b111 D
b1 C
bx B
b111 A
b0 @
b10 ?
b0 >
b1 =
b111 <
b1000 ;
bx :
b111 9
b0 8
b10 7
b1 6
b0 5
b100000000111 4
b111 3
b1 2
b1 1
b111 0
b1000 /
b0 .
b0 -
bx ,
bx +
bx *
bz )
bx (
z'
bx &
b0 %
z$
bz #
z"
z!
$end
#8000
b101 0
b101 <
b101 H
b101 W
b101 ]
b101 V
b101 :
b101 B
b101 R
b11 _
b11 1
b11 =
b11 I
b111 ^
b111 /
b111 ;
b111 G
b11 Y
b11 7
b11 ?
b11 O
b11 \
b101 Z
b11 C
b11 2
b11 J
b11 S
b101 D
b101 3
b101 K
b101 T
b10 F
b10 6
b10 N
b10 [
b110000000101 E
b110000000101 4
b110000000101 L
b110000000101 X
#16000
b0 0
b0 <
b0 H
b0 W
b0 ]
b1100 U
b1100 9
b1100 A
b1100 Q
b11 a
b11 8
b11 @
b11 P
b10 _
b10 1
b10 =
b10 I
b11 ^
b11 /
b11 ;
b11 G
b110 Y
b110 7
b110 ?
b110 O
b110 \
b0 Z
b10 C
b10 2
b10 J
b10 S
b1100 D
b1100 3
b1100 K
b1100 T
b11 F
b11 6
b11 N
b11 [
b1100000000000 E
b1100000000000 4
b1100000000000 L
b1100000000000 X
#24000
b110010 0
b110010 <
b110010 H
b110010 W
b110010 ]
b11 `
b11 5
b11 >
b11 M
b0 _
b0 1
b0 =
b0 I
b110010 ^
b110010 /
b110010 ;
b110010 G
b101 Y
b101 7
b101 ?
b101 O
b101 \
b110010 Z
b0 C
b0 2
b0 J
b0 S
b100 F
b100 6
b100 N
b100 [
b1010000110010 E
b1010000110010 4
b1010000110010 L
b1010000110010 X
#32000
b111101 0
b111101 <
b111101 H
b111101 W
b111101 ]
b0 `
b0 5
b0 >
b0 M
b10 ^
b10 /
b10 ;
b10 G
b100000 Y
b100000 7
b100000 ?
b100000 O
b100000 \
b111101 Z
b111 D
b111 3
b111 K
b111 T
b101 F
b101 6
b101 N
b101 [
b1000000000111101 E
b1000000000111101 4
b1000000000111101 L
b1000000000111101 X
#40000
b11110100 0
b11110100 <
b11110100 H
b11110100 W
b110100 ]
b0 a
b0 8
b0 @
b0 P
b111110100 ^
b111110100 /
b111110100 ;
b111110100 G
b11000 Y
b11000 7
b11000 ?
b11000 O
b11000 \
b111110100 Z
b1011 F
b1011 6
b1011 N
b1011 [
b110000111110100 E
b110000111110100 4
b110000111110100 L
b110000111110100 X
#48000
